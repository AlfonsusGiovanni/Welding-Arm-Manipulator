/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "LCD_I2C.h"
#include "Keypad_Driver.h"
#include "RS232_Driver.h"
#include "EEPROM_lib.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

//--- LCD MENU TYPEDEF ---//
////////////////////////////
typedef enum{
	BOOTING_MENU,
	AUTO_HOME_MENU,
	HOMING_MENU,
	HOME_MENU,
	PREP_MENU,
	MAPPING_MENU,
	PREVIEW_MENU,
	WELDING_MENU,
	PAUSE_MENU,
	STOP_MENU,
	HOLD_MENU,
	MAPPING_ERROR_MENU,
	PREVIEW_ERROR_MENU,
	MAPPING_SAVE_MENU,
	POINT_SET_MENU,
	POINT_UNSET_MENU,
}LCD_Menu_t;

LCD_Menu_t select_menu;
////////////////////////////


//--- KEYPAD TYPEDEF ---//
//////////////////////////
Keypad_t keypad;
//////////////////////////


//--- EEPROM TYPEDEF ---//
//////////////////////////
EEPROM_t eeprom;

typedef enum{
	UPDATE_ALL = 0x01,
	SELECTED_ONLY,
}Mem_Update_t;
//////////////////////////


//--- RS232 TYPEDEF ---//
//////////////////////////
Data_Get_t command;
//////////////////////////

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/*EEPROM ADDRESS SET*/
//-----------------------------------
#define EEPROM_ADDRESS					0xA0
#define DATA_BYTE_SHIFT					0x02
#define DATA_PAGE_SHIFT					0x01
//-----------------------------------

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;
I2C_HandleTypeDef hi2c2;

TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;

UART_HandleTypeDef huart1;
DMA_HandleTypeDef hdma_usart1_rx;

/* USER CODE BEGIN PV */

/*PENDANT GLOBAL VARIABLE*/
//////////////////////////////
bool 
saved_dist    		= true,
saved_speed   		= true,
saved_prev				= true,
state_booting 		= false,
state_home 				= false,
state_running 		= false,
stop 							= false,
prep_done 				= false,
mapped_start_array[250],
mapped_end_array[250];

uint8_t
stored_welding_data[3],
running_speed,
max_speed = 150,
mapped_array[250],
mapped_points[250],
mapped_pattern[250],
mapped_speed[250];

uint16_t 
mapping_point,
total_mapped_points,
preview_point, welding_point,
preview_pattern, welding_pattern,
preview_speed, welding_speed,
max_welding_point = 250;

float
angle_value[6], angle_limit,
pos_value[3], pos_limit,
A1, A2, A3, A4, A5, A6,
moveX, moveY, moveZ,
distance_val,
max_distance = 300;

char
string_distance[20] = "0",
string_preview[20] 	= "0",
string_speed[20]		= "0";
//////////////////////////////


/*MENU MODE VARIABLE*/
///////////////////////////////////
bool
home_state = true,
mapping_state = false,
preview_state = false,
welding_state = false;

float
increase_decrease_value = 2.5;

char
home_menu[]					= "(HOME)",	
preparation[]     	= "(PREP)",
mapping_menu[]    	= "(MAP)",
preview_menu[] 			= "(PREV)",
welding_menu[]			= "(WELD)",
mem_menu[]        	= "(MEM)",

pos_ctrl[] 					= "(POS)",
angle_ctrl[] 				= "(ANG)",

cont_change[] 			= "(CON)",
dist_change[] 			= "(DIS)",
step_change[] 			= "(STP)",

mapping_mode[]			= "(MAPPING)",
welding_mode[] 			= "(WELDING)",
preview_mode[] 			= "(PREVIEW)",

low_speed[] 				= "LOW",
med_speed[] 				= "MED",
high_speed[] 				= "HIGH",

linear_mode[]				= "LINEAR",
circular_mode[] 		= "CIRCULAR",
wave_mode[] 				= "WAVE",

string_max_dist[] 	= "300      ",
string_max_point[] 	= "250      ",
string_max_speed[]	= "150      ";

int16_t 
ctrl_mode_counter,
change_value_counter,
move_var_counter,
run_mode_counter,
speed_mode_counter,
mapping_menu_counter,
mapped_point_counter,
start_point_counter,
end_point_counter,
pattern_sel_counter,
mapped_array_counter,
welding_menu_counter,
add_col;

char num_keys[] = {
'1', '2', '3', '4', '5',
'6', '7', '8', '9', '0',
};
///////////////////////////////////

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_I2C1_Init(void);
static void MX_I2C2_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM3_Init(void);
static void MX_TIM4_Init(void);
/* USER CODE BEGIN PFP */

// MENU HANDLER FUNCTION PROTOTYPE
void show_menu(LCD_Menu_t menu);
void ui_handler(void);
bool check_numkeys_pressed(void);


// EEPROM HANDLER FUNCTION PROTOTYPE
void Save_WeldingData(uint8_t welding_point, uint8_t welding_pattern, uint8_t welding_speed);
void Delete_WeldingData(uint8_t welding_point);
void Read_WeldingData(uint8_t welding_point, uint8_t* stored_data);
void Update_Data(Mem_Update_t update_type);
void Format_mem(void);

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/*LCD MENU CONFIGURATION*/
//------------------------------------------------------------
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
	if(htim->Instance == TIM2) show_menu(select_menu);
}
//------------------------------------------------------------


/*KEYPAD CONFIGURATION*/
//-------------------------------
unsigned long 
prev_tick,
debounce = 200;

const uint8_t
num_rows = 5, 
num_cols = 4;

char key[num_rows][num_cols] = {
	{'Q', 'W', 'R', 'T'},
	{'1', '2', '3', 'U'}, 
	{'4', '5', '6', 'D'},
	{'7', '8', '9', '.'},
	{'<', '0', '>', '#'}
};

char 
prev_keys,
keys;
//-------------------------------


/*RS232 CONFIGURATION*/
//------------------------------------------------------
uint32_t RS232_state, RS232_err_status;
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
	Get_command(&command);
	RS232_state = check_state();
	RS232_err_status = check_error();
}
//------------------------------------------------------

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
	
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_I2C1_Init();
  MX_I2C2_Init();
  MX_USART1_UART_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_TIM4_Init();
  /* USER CODE BEGIN 2 */
	

	/*LCD CONFIGURATION*/
	//----------------------------
	lcd_init(&hi2c2);
	select_menu = BOOTING_MENU;
	HAL_TIM_Base_Start_IT(&htim2);
	HAL_Delay(500);
	//----------------------------
	
	
	/*EEPROM CONFIGURATION*/
	//---------------------------------------------------------------------
	EEPROM_Init(&hi2c1, &eeprom, MEM_SIZE_256Kb, 0xA0);
	Update_Data(UPDATE_ALL);
	//---------------------------------------------------------------------
	
	
	/*RS232 COM CONFIGURATION*/
	//-------------------------
	RS232_Init(&huart1);
	Start_get_command();
	Get_command(&command);
	HAL_Delay(500);
	//-------------------------
	
	
	/*KEYPAD CONFIGURATION*/	
	//----------------------------------------------------------
	keypad.row_port[0] = GPIOA, keypad.row_pin[0] = GPIO_PIN_1;
	keypad.row_port[1] = GPIOA, keypad.row_pin[1] = GPIO_PIN_2;
	keypad.row_port[2] = GPIOA, keypad.row_pin[2] = GPIO_PIN_3;
	keypad.row_port[3] = GPIOA, keypad.row_pin[3] = GPIO_PIN_4;
	keypad.row_port[4] = GPIOA, keypad.row_pin[4] = GPIO_PIN_5;
	
	keypad.col_port[0] = GPIOC, keypad.col_pin[0] = GPIO_PIN_13;
	keypad.col_port[1] = GPIOC, keypad.col_pin[1] = GPIO_PIN_14;
	keypad.col_port[2] = GPIOC, keypad.col_pin[2] = GPIO_PIN_15;
	keypad.col_port[3] = GPIOA, keypad.col_pin[3] = GPIO_PIN_0;
	
	Keypad_Init(&keypad, makeKeymap(key), num_rows, num_cols);
	HAL_Delay(500);
	//----------------------------------------------------------
	
	
	/*ALL PREPARATION COMPLETED - BOOTING DONE*/
	//------------------------------------------
	select_menu = HOME_MENU;
	lcd_clear();
	prep_done = true;
	//------------------------------------------
	
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
		ui_handler();
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }

  /** Enables the Clock Security System
  */
  HAL_RCC_EnableCSS();
}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 400000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief I2C2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C2_Init(void)
{

  /* USER CODE BEGIN I2C2_Init 0 */

  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
  hi2c2.Init.ClockSpeed = 100000;
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 287;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 49999;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}

/**
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 0;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 65535;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}

/**
  * @brief TIM4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_Encoder_InitTypeDef sConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 0;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 65535;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI1;
  sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC1Filter = 0;
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC2Filter = 0;
  if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */

}

/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 38400;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : LED_Pin */
  GPIO_InitStruct.Pin = LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/*--- USER INTERFACE HANDLER ---*/
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void ui_handler(void){
	keys = Keypad_Read(&keypad);
	if(keys != prev_keys && keys != 0x00) lcd_clear();
	
	/* AUTO HOME MENU HANDLER */////////////////////////////////////////////
	if(select_menu == AUTO_HOME_MENU){
		while(1){
			keys = Keypad_Read(&keypad);
			if(keys == '#' && prev_keys != keys){
				lcd_clear();
				while(1){
					Send_auto_home();
					if(command.feedback == AUTO_HOME_DONE){
						lcd_clear();
						select_menu = HOME_MENU;
						HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);
						HAL_Delay(100);
						HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
						break;
					}
					else select_menu = HOMING_MENU;
				}
				break;
			}
			else if(keys == '.' && prev_keys != keys){
				lcd_clear();
				select_menu = HOME_MENU;
				break;
			}
		}
	}
	////////////////////////////////////////////////////////////////////////
	
	
	/* HOME MENU HANDLER */////////////////////////////////////////////////////////////////
	else if(select_menu == HOME_MENU){
		home_state = true;
		
		// AUTO HOME ************************
		if(keys == 'Q' && prev_keys != keys){
			select_menu = AUTO_HOME_MENU;
		}
		// **********************************
		
		
		// CHANGE MOVE CONTROL ***************************
		else if(keys == 'W' && prev_keys != keys){
			move_var_counter = 0;
			ctrl_mode_counter++;
			if(ctrl_mode_counter > 1) ctrl_mode_counter = 0;
		}
		// ***********************************************
		
		
		// CHANGE CURSOR **************************************************************
		else if(keys == 'R' && prev_keys != keys){
			move_var_counter++;
			if(ctrl_mode_counter == 0 && move_var_counter > 2) move_var_counter = 0;
			else if(ctrl_mode_counter == 1 && move_var_counter > 5) move_var_counter = 0;
		}
		// ****************************************************************************
		
		
		// SELECT MOVE VALUE ***********************************
		else if(keys == 'T' && prev_keys != keys){
			change_value_counter++;
			if(change_value_counter > 2) change_value_counter = 0;
		}
		// *****************************************************
		
		
		// MOVE VALUE BY DISTANCE *************************************************************
		else if((change_value_counter == 1 && check_numkeys_pressed() == true) || keys == '<'){
			add_col = 0;
			*string_distance = '0';
			
			while(1){
				saved_dist = false;
				if(keys != prev_keys && keys != 0x00) lcd_clear();
				
				// INSERT VALUE
				if(check_numkeys_pressed() == true && prev_keys != keys){
					string_distance[add_col] = keys;
					add_col++;
				}
				
				// DELETE VALUE
				if(keys == '<' && prev_keys != keys){
					if(add_col > 0) add_col-=1;
					
					if(add_col == 0) string_distance[add_col] = '0';
					else string_distance[add_col] = ' ';
				}
				
				// SAVE VALUE
				if(keys == '>' && prev_keys != keys){
					sscanf(string_distance, "%f", &distance_val);
					if(distance_val >= max_distance){
						memcpy(string_distance, string_max_dist, sizeof(string_max_dist));
						distance_val = max_distance;
					}
					saved_dist = true;
					break;
				}
	
				prev_keys = keys;
			}
		}
		// ************************************************************************************
		
		
		// MOVE VALUE BY STEP *******************************************
		else if(change_value_counter == 2) increase_decrease_value = 0.1;
		// **************************************************************
		
		
		// MOVE VALUE CONTINUOUS **********
		else increase_decrease_value = 2.5;
		// ********************************
		
		
		// INCLREASE VALUE **********************************************************
		if(keys == 'U' && HAL_GetTick() - prev_tick > debounce){
			if(ctrl_mode_counter == 0){
				for(int i=0; i<3; i++) if(move_var_counter == i){
					if(change_value_counter != 1) pos_value[i] += increase_decrease_value;
					else pos_value[i] += distance_val;
				}
			}
			else{
				for(int i=0; i<6; i++) if(move_var_counter == i){
					if(change_value_counter != 1) angle_value[i] += increase_decrease_value;
					else angle_value[i] += distance_val;
				}
			}
			prev_tick = HAL_GetTick();
		}
		// ***************************************************************************
		
		
		// DECREASE VALUE ************************************************************
		else if(keys == 'D' && HAL_GetTick() - prev_tick > debounce){
			if(ctrl_mode_counter == 0){
				for(int i=0; i<3; i++) if(move_var_counter == i){
					if(change_value_counter != 1) pos_value[i] -= increase_decrease_value;
					else pos_value[i] -= distance_val;
				}
			}
			else{
				for(int i=0; i<6; i++) if(move_var_counter == i){
					if(change_value_counter != 1) angle_value[i] -= increase_decrease_value;
					else angle_value[i] -= distance_val;
				}
			}
			prev_tick = HAL_GetTick();
		}
		// ***************************************************************************
		
		
		// MOVE TO PREPARATION MENU *********
		if(keys == '#' && prev_keys != keys){
			home_state = false;
			run_mode_counter = 0;
			select_menu = PREP_MENU;
		}
		// **********************************
	}
	///////////////////////////////////////////////////////////////////////////////////////
	
	
	/* PREPARATION MENU HANDLER *////////////////////////////////////////////////////////////////
	else if(select_menu == PREP_MENU){
		mapping_state = false;
		preview_state = false;
		welding_state = false;
		
		// BACT TO HOME MENU *****************
		if(keys == '.' && prev_keys != keys){
			select_menu = HOME_MENU;
		}
		// ***********************************
		
		
		// CHANGE RUNNING MODE *************************
		else if(keys == 'Q' && prev_keys != keys){
			run_mode_counter++;
			if(run_mode_counter > 2) run_mode_counter = 0;
		}
		// *********************************************
		
		
		// MAPPING PREPARATION MENU ***************************************************************
		if(run_mode_counter == 0){
			// CHECK NEXT MAPPED POINT
			if(keys == 'U' && prev_keys != keys){
				mapped_point_counter++;
				if(mapped_point_counter >= max_welding_point) mapped_point_counter = max_welding_point;
			}
			
			// CHECK PREVIOUS MAPPED POINT
			else if(keys == 'D' && prev_keys != keys){
				mapped_point_counter--;
				if(mapped_point_counter <= 0) mapped_point_counter = 0;
			}
			
			// MAPPING RUN
			else if(keys == '#' && prev_keys != keys){
				mapping_state = true;
				select_menu = MAPPING_MENU;
				mapping_menu_counter = 0;
			}
		}
		// ****************************************************************************************
		
		
		// PREVIEW PREPARATION MENU ****************************************************
		else if(run_mode_counter == 1){
			// CHECK FIRST NUMKEY INPUT
			if(check_numkeys_pressed() == true || keys == '<'){
				add_col = 0;
				*string_preview = '0';
				
				while(1){
					if(keys != prev_keys && keys != 0x00) lcd_clear();
					saved_prev = false;
					
					// INSERT VALUE
					if(check_numkeys_pressed() == true && prev_keys != keys && add_col < 3){
						string_preview[add_col] = keys;
						add_col++;
					}
					
					// SAVE VALUE
					else if((keys == '>') && prev_keys != keys){
						preview_point = atoi(string_preview);
						if(preview_point > max_welding_point){
							memcpy(string_preview, string_max_point, sizeof(string_max_point));
							preview_point = max_welding_point;
						}
						saved_prev = true;
						break;
					}
					
					// DELETE VALUE
					else if(keys == '<' && prev_keys != keys){
						if(add_col > 0) add_col-=1;
						
						if(add_col == 0) string_preview[add_col] = '0';
						else string_preview[add_col] = ' ';
					}
					prev_keys = keys;
				}
			}
			
			// PREVIEW RUN
			else if(keys == '#' && prev_keys != keys){
				preview_state = true;
				select_menu = PREVIEW_MENU;
				mapping_menu_counter = 0;
			}
		}
		// **********************************************************************
		
		
		// WELDING PREPARATION MENU ***************************
		else if(run_mode_counter == 2){
			// CHANGE RUNNING SPEED
			if(keys == 'W' && prev_keys != keys){
				speed_mode_counter++;
				if(speed_mode_counter > 2) speed_mode_counter = 0;
			}
			
			// WELDING RUN
			else if(keys == '#' && prev_keys != keys){
				welding_state = true;
				select_menu = WELDING_MENU;
				mapping_menu_counter = 0;
				ctrl_mode_counter = 0;
				preview_point = 0;
				preview_pattern = 0;
				preview_speed = 0;
			}
		}
		// ****************************************************		
	}
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	
	/* MAPPING MENU UI HANDLER *////////////////////////////////////////////////////////////////////////
	else if(select_menu == MAPPING_MENU){
		// MOVE TO PREPARATION MENU *********
		if(keys == '.' && prev_keys != keys){
			run_mode_counter = 0;
			select_menu = PREP_MENU;
		}
		// **********************************
		
		
		// CHANGE MAPPING MENU *********************************
		else if(keys == 'Q' && prev_keys != keys){
			mapping_menu_counter++;
			if(mapping_menu_counter > 2) mapping_menu_counter = 0;
		}
		// *****************************************************
		
		
		// MAPPING MENU 1 ************************************************************************ 
		if(mapping_menu_counter == 0){
			// CHANGE MOVE CONTROL
			if(keys == 'W' && prev_keys != keys){
				move_var_counter = 0;
				ctrl_mode_counter++;
				if(ctrl_mode_counter > 1) ctrl_mode_counter = 0;
			}
			
			// CHANGE CURSOR FOR SELECT MOVE VARIABLE
			else if(keys == 'R' && prev_keys != keys){
				move_var_counter++;
				if(ctrl_mode_counter == 0 && move_var_counter > 2) move_var_counter = 0;
				else if(ctrl_mode_counter == 1 && move_var_counter > 5) move_var_counter = 0;
			}
			
			// SELECT MOVE VALUE
			else if(keys == 'T' && prev_keys != keys){
				change_value_counter++;
				if(change_value_counter > 2) change_value_counter = 0;
			}
			
			// MOVE VALUE BY DISTANCE
			else if(check_numkeys_pressed() == true || keys == '<'){
				add_col = 0;
				*string_distance = '0';
				
				while(1){
					saved_dist = false;
					if(keys != prev_keys && keys != 0x00) lcd_clear();
					
					// INSERT VALUE
					if(check_numkeys_pressed() == true && prev_keys != keys){
						string_distance[add_col] = keys;
						add_col++;
					}
					
					// SAVE VALUE
					else if(keys == '>' && prev_keys != keys){
						sscanf(string_distance, "%f", &distance_val);
						if(distance_val >= max_distance){
							memcpy(string_distance, string_max_dist, sizeof(string_max_dist));
							distance_val = max_distance;
						}
						saved_dist = true;
						break;
					}
					
					// DELETE VALUE
					else if(keys == '<' && prev_keys != keys){
						if(add_col > 0) add_col-=1;
						
						if(add_col == 0) string_distance[add_col] = '0';
						else string_distance[add_col] = ' ';
					}
		
					prev_keys = keys;
				}
			}
			
			// MOVE VALUE BY STEP
			else if(change_value_counter == 2) increase_decrease_value = 0.1;
			
			// MOVE VALUE CONTINUOUS
			else increase_decrease_value = 2.5;
			
			// INCLREASE VALUE
			if(keys == 'U' && HAL_GetTick() - prev_tick > debounce){
				if(ctrl_mode_counter == 0){
					for(int i=0; i<3; i++) if(move_var_counter == i){
						if(change_value_counter != 1) pos_value[i] += increase_decrease_value;
						else pos_value[i] += distance_val;
					}
				}
				
				else{
					for(int i=0; i<6; i++) if(move_var_counter == i){
						if(change_value_counter != 1) angle_value[i] += increase_decrease_value;
						else angle_value[i] += distance_val;
					}
				}
				prev_tick = HAL_GetTick();
			}
			
			// DECREASE VALUE
			else if(keys == 'D' && HAL_GetTick() - prev_tick > debounce){
				if(ctrl_mode_counter == 0){
					for(int i=0; i<3; i++) if(move_var_counter == i){
						if(change_value_counter != 1) pos_value[i] -= increase_decrease_value;
						else pos_value[i] -= distance_val;
					}
				}
				
				else{
					for(int i=0; i<6; i++) if(move_var_counter == i){
						if(change_value_counter != 1) angle_value[i] -= increase_decrease_value;
						else angle_value[i] -= distance_val;
					}
				}
				prev_tick = HAL_GetTick();
			}
		}
		// ***************************************************************************************
		
		
		// MAPPING MENU 2 *******************************************************************
		else if(mapping_menu_counter == 1){
			// CHANGE CURSOR FOR SELECT WELDING POINT
			if(keys == 'R' && prev_keys != keys){
				move_var_counter++;
				if(move_var_counter > 1) move_var_counter = 0;
			}
			
			// INCLREASE VALUE
			if(keys == 'U' && HAL_GetTick() - prev_tick > debounce){
				if(move_var_counter == 0){
					start_point_counter++;
					if(start_point_counter > max_welding_point) start_point_counter = 0;
				}
				
				else if(move_var_counter ==1){
					end_point_counter++;
					if(end_point_counter > max_welding_point) end_point_counter = 0;
				}
				prev_tick = HAL_GetTick();
			}
			
			// DECREASE VALUE
			else if(keys == 'D' && HAL_GetTick() - prev_tick > debounce){
				if(move_var_counter == 0){
					start_point_counter--;
					if(start_point_counter < 0) start_point_counter = max_welding_point;
				}
				
				else if(move_var_counter ==1){
					end_point_counter--;
					if(end_point_counter < 0) end_point_counter = max_welding_point;
				}
				prev_tick = HAL_GetTick();
			}
			
			// SET MAPPING POINT
			else if(keys == '>' && prev_keys != keys && mapping_menu_counter != 0){
				if(move_var_counter == 0 && start_point_counter != 0){
					mapped_start_array[start_point_counter] = true;
					Send_mapping(start_point_counter, START_POINT, NOT_SET, 0, SAVE_VALUE);
				}
				else if(move_var_counter == 1 && end_point_counter != 0){
					mapped_end_array[end_point_counter] = true;
					Send_mapping(end_point_counter, END_POINT, NOT_SET, 0, SAVE_VALUE);
				}
				
				select_menu = POINT_SET_MENU;
				HAL_Delay(1500);
				lcd_clear();
				select_menu = MAPPING_MENU;
			}
			
			// UNSET MAPPING POINT 
			else if(keys == '<' && prev_keys != keys && mapping_menu_counter != 0){
				if(move_var_counter == 0){
					mapped_start_array[start_point_counter] = false;
					Send_mapping(start_point_counter, START_POINT, NOT_SET, 0, DELETE_VALUE);
				}
				else if(move_var_counter == 1){
					mapped_end_array[end_point_counter] = false;
					Send_mapping(end_point_counter, END_POINT, NOT_SET, 0, DELETE_VALUE);
				}
				
				select_menu = POINT_UNSET_MENU;
				HAL_Delay(1500);
				lcd_clear();
				select_menu = MAPPING_MENU;
			}
		}
		// **********************************************************************************
		
		
		// MAPPING MENU 3 ************************************************************
		else if(mapping_menu_counter == 2){
			// CHANGE PATTERN
			if(keys == 'W' && prev_keys != keys){
				pattern_sel_counter++;
				if(pattern_sel_counter > 2) pattern_sel_counter = 0;
			}
			
			// SAVE ALL MAPPING POINT DATA PATTERN
			if(keys == '#' && prev_keys != keys){
				if((mapped_start_array[start_point_counter] & mapped_end_array[end_point_counter]) == true){
					total_mapped_points = 0;
					
					if(pattern_sel_counter == 0){
						Send_mapping(start_point_counter&end_point_counter, PATTERN, LINEAR, running_speed, SAVE_VALUE);
						Save_WeldingData(start_point_counter, LINEAR, running_speed);
					}
					
					else if(pattern_sel_counter == 1){
						Send_mapping(start_point_counter&end_point_counter, PATTERN, CIRCULAR, running_speed, SAVE_VALUE);
						Save_WeldingData(start_point_counter, CIRCULAR, running_speed);
					}
					
					else if(pattern_sel_counter == 2){
						Send_mapping(start_point_counter&end_point_counter, PATTERN, WAVE, running_speed, SAVE_VALUE);
						Save_WeldingData(start_point_counter, WAVE, running_speed);
					}
					HAL_Delay(50);
					
					select_menu = MAPPING_SAVE_MENU;
					Update_Data(UPDATE_ALL);
					lcd_clear();
					select_menu = MAPPING_MENU;
					mapping_menu_counter = 0;
				}
				
				else{
					select_menu = MAPPING_ERROR_MENU;
					HAL_Delay(3000);
					lcd_clear();
					select_menu = MAPPING_MENU;
					mapping_menu_counter = 1;
				}
			}
			
			// CHANGE MAPPED POINT MOVE SPEED
			else if(check_numkeys_pressed() == true || keys == '<'){
				add_col = 0;
				*string_speed = '0';
				
				while(1){
					saved_speed = false;
					if(keys != prev_keys && keys != 0x00) lcd_clear();
					
					// INSERT VALUE
					if(check_numkeys_pressed() == true && prev_keys != keys && add_col < 3){
						string_speed[add_col] = keys;
						add_col++;
					}
					
					// SET SPEED VALUE
					else if(keys == '>' && prev_keys != keys){
						running_speed = atoi(string_speed);
						if(running_speed >= max_speed){
							memcpy(string_speed, string_speed, sizeof(string_speed));
							running_speed = max_speed;
						}
						saved_speed = true;
						break;
					}
					
					// UNSET SPEED VALUE
					else if(keys == '<' && prev_keys != keys){
						if(add_col > 0) add_col-=1;
						
						if(add_col == 0) string_speed[add_col] = '0';
						else string_speed[add_col] = ' ';
					}
		
					prev_keys = keys;
				}
			}
		}
		// ***************************************************************************
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////
	
	
	/* PREVIEW MENU HANDLER */////////////////////////////////////////////////////////////////////////////////////////////////
	else if(select_menu == PREVIEW_MENU){
		if((preview_point & mapped_points[preview_point-1]) == preview_point && preview_point != 0 && preview_speed != 0){
			preview_pattern = mapped_pattern[preview_point-1];
			preview_speed = mapped_speed[preview_point-1];
			
			if(command.feedback == CURRENT_POINT_DONE){
				change_value_counter = 0;
				ctrl_mode_counter = 0;
				move_var_counter = 0;
				select_menu = HOME_MENU;
			}
			
			if(keys == '.' && prev_keys != keys){
				select_menu = STOP_MENU;
			}
		}
		
		else if((preview_point & mapped_points[preview_point-1]) != preview_point || preview_point == 0 || preview_speed == 0){
			lcd_clear();
			select_menu = PREVIEW_ERROR_MENU;
			HAL_Delay(2000);
			lcd_clear();
			select_menu = PREP_MENU;
			run_mode_counter = 1;
		}
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	
	/* WELDING MENU HANDLER *//////////////////////////////////
	else if(select_menu == WELDING_MENU){
		preview_point = command.welding_point;
		preview_pattern = command.pattern_type;
		preview_speed = command.welding_speed;
		
		// PAUSE MENU ***********************
		if(keys == 'Q' && prev_keys != keys){
			// kirim command pause
			select_menu = PAUSE_MENU;
		}
		// **********************************
		

		// CHANGE WELDING MENU *********************************
		else if(keys == 'W' && prev_keys != keys){
			ctrl_mode_counter++;
			if(ctrl_mode_counter > 1) ctrl_mode_counter = 0;
		}
		// *****************************************************
		
		
		// CHANGE WELDING MENU *********************************
		else if(keys == 'R' && prev_keys != keys){
			welding_menu_counter++;
			if(welding_menu_counter > 1) welding_menu_counter = 0;
		}
		// *****************************************************
		
		
		// STOP MENU *****************************
		else if(keys == '.' && prev_keys != keys){
			select_menu = STOP_MENU;
		}
		// ***************************************
	}
	//////////////////////////////////////////////////////////
	
	
	/* PAUSE MENU HANDLER *///////////////////////////////
	else if(select_menu == PAUSE_MENU){
		// CONTINUE MENU ***********************************
		while(1){
			keys = Keypad_Read(&keypad);
			if(keys != prev_keys && keys != 0x00) lcd_clear();
			
			Send_running(RUNNING_PAUSE);
			if(keys == '#' && prev_keys != keys){
				select_menu = WELDING_MENU;
			}
			
			prev_keys = keys;
		}
		// *************************************************
	}
	//////////////////////////////////////////////////////
	
	
	/* STOP MENU HANDLER */////////////////////
	else if(select_menu == STOP_MENU){
		// WAIT FOR AUTO HOMING DONE ************
		while(1){
			Send_running(RUNNING_STOP);
			if(command.feedback == AUTO_HOME_DONE){
				ctrl_mode_counter = 0,
				change_value_counter = 0,
				move_var_counter = 0,
				run_mode_counter = 0,
				select_menu = HOME_MENU;
				break;
			}
		}
		// **************************************
	}
	////////////////////////////////////////////
	
	prev_keys = keys;
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*--- LCD MENU ---*/
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void show_menu(LCD_Menu_t menu){
	/* BOOTING MENU *////////////////
	if(menu == BOOTING_MENU){
		lcd_set_cursor(3, 1);
		lcd_printstr("SYSTEM BOOTING");
		lcd_set_cursor(4, 2);
		lcd_printstr("PLEASE  WAIT");
	}
	/////////////////////////////////
	
	
	/* AUTO HOME MENU *//////////////////
	else if(menu == AUTO_HOME_MENU){
		lcd_set_cursor(3, 1);
		lcd_printstr("PRESS  ENTER");
		lcd_set_cursor(1, 2);
		lcd_printstr("TO START AUTO HOME");
	}
	/////////////////////////////////////
	
	
	/* HOMING MENU *//////////////
	else if(menu == HOMING_MENU){
		lcd_set_cursor(0, 0);	
			lcd_printstr("XP:HOMING");
			lcd_set_cursor(0, 1);
			lcd_printstr("YP:HOMING");
			lcd_set_cursor(0, 2);
			lcd_printstr("ZP:HOMING");
			
			lcd_set_cursor(7, 3);
			lcd_printstr(home_menu);
		
			lcd_set_cursor(15, 3);
			lcd_printstr(pos_ctrl);
	}
	//////////////////////////////
	
	
	/* HOME MENU *//////////////////////////////////////////////////
	else if(menu == HOME_MENU){		
		// SHOW POS CTRL *********************
		if(ctrl_mode_counter == 0){
			lcd_set_cursor(9, move_var_counter);
			lcd_printstr("<");
			
			lcd_set_cursor(0, 0);	
			lcd_printstr("XP:");
			lcd_printfloat(pos_value[0], 1);
			lcd_set_cursor(0, 1);
			lcd_printstr("YP:");
			lcd_printfloat(pos_value[1], 1);
			lcd_set_cursor(0, 2);
			lcd_printstr("ZP:");
			lcd_printfloat(pos_value[2], 1);
			
			lcd_set_cursor(15, 3);
			lcd_printstr(pos_ctrl);
		}
		// ***********************************
		
		
		// SHOW ANGLE CTRL **************************
		else if(ctrl_mode_counter == 1){
			if(move_var_counter < 3){
				lcd_set_cursor(9, move_var_counter);
				lcd_printstr("<");
			}
			
			else if(move_var_counter > 2){
				lcd_set_cursor(19, move_var_counter-3);
				lcd_printstr("<");
			}
			
			lcd_set_cursor(0, 0);			
			lcd_printstr("A1:");			
			lcd_printfloat(angle_value[0], 1);				
			lcd_set_cursor(0, 1);			
			lcd_printstr("A2:");			
			lcd_printfloat(angle_value[1], 1);				
			lcd_set_cursor(0, 2);			
			lcd_printstr("A3:");			
			lcd_printfloat(angle_value[2], 1);				
			
			lcd_set_cursor(10, 0);
			lcd_printstr("A4:");
			lcd_printfloat(angle_value[3], 1);
			lcd_set_cursor(10, 1);
			lcd_printstr("A5:");
			lcd_printfloat(angle_value[4], 1);
			lcd_set_cursor(10, 2);
			lcd_printstr("A6:");
			lcd_printfloat(angle_value[5], 1);
			
			lcd_set_cursor(15, 3);
			lcd_printstr(angle_ctrl);
		}
		// ******************************************
		
		
		// CONTINUES MOVE **************************************
		lcd_set_cursor(0, 3);	
		if(change_value_counter == 0) lcd_printstr(cont_change);
		// *****************************************************
		
		
		// DISTANCE MOVE ***********************
		else if(change_value_counter == 1){
			lcd_printstr(dist_change);
			lcd_set_cursor(6, 3);	
			lcd_printstr(string_distance);
			
			if(!saved_dist && add_col != 0){
				lcd_set_cursor(6+add_col, 3);	
				lcd_printstr("* ");
			} 
			else if(!saved_dist && add_col == 0){
				lcd_set_cursor(7, 3);	
				lcd_printstr("* ");
			}
		}
		// *************************************
		
		
		// STEP MOVE ************************************************
		else if(change_value_counter == 2) lcd_printstr(step_change);
		// **********************************************************
		
		
		// SHOW CURRENT MENU *********
		if(change_value_counter != 1){
			lcd_set_cursor(7, 3);
			lcd_printstr(home_menu);
		}
		// ***************************
	}
	///////////////////////////////////////////////////////////////
	
	
	/* PREPARATION MENU */////////////////////////////////////
	else if(menu == PREP_MENU){
		// MAPPING PREP *****************
		if(run_mode_counter == 0){
			lcd_set_cursor(0, 0);
			lcd_printstr("Mapped Points");
			lcd_set_cursor(17, 0);
			if(mapped_points[mapped_point_counter] == 0){
				lcd_printstr("-");
				}
			else lcd_printint(mapped_points[mapped_point_counter]);
			
			lcd_set_cursor(0, 3);
			lcd_printstr(mapping_mode);
		}
		// ******************************
		
		
		// PREVIEW PREP ********************
		if(run_mode_counter == 1){
			lcd_set_cursor(0, 0);
			lcd_printstr("Select Point");
			if(!saved_prev) lcd_printstr("*");
			else lcd_printstr(" ");
				
			lcd_set_cursor(17, 0); 
			lcd_printstr(string_preview);
			
			lcd_set_cursor(0, 3);
			lcd_printstr(preview_mode);
		}
		// *********************************
		
		
		// WELDING PREP *******************************************
		if(run_mode_counter == 2){
			lcd_set_cursor(0, 0);
			lcd_printstr("Set Speed");
			lcd_set_cursor(17, 0);
			if(speed_mode_counter == 0) lcd_printstr(low_speed);
			else if(speed_mode_counter == 1) lcd_printstr(med_speed);
			else if(speed_mode_counter == 2){
				lcd_set_cursor(16, 0);
				lcd_printstr(high_speed);
			}
			
			lcd_set_cursor(0, 1);
			lcd_printstr("Total Mapped");
			lcd_set_cursor(17, 1);
			lcd_printint(total_mapped_points);
			
			lcd_set_cursor(0, 3);
			lcd_printstr(welding_mode);
		}
		// ********************************************************
		
		
		// SHOW CURRENT MENU ******
		lcd_set_cursor(14, 3);
		lcd_printstr(preparation);
		// ************************
	}
	//////////////////////////////////////////////////////////
	
	
	/* MAPPING MENU 1 *////////////////////////////////////////////
	else if(menu == MAPPING_MENU && mapping_menu_counter == 0){
		// SHOW CARTESIAN COORDINATE **********
		if(ctrl_mode_counter == 0){
			lcd_set_cursor(9, move_var_counter);
			lcd_printstr("<");
			
			lcd_set_cursor(0, 0);	
			lcd_printstr("XP:");
			lcd_printfloat(pos_value[0], 1);
			lcd_set_cursor(0, 1);
			lcd_printstr("YP:");
			lcd_printfloat(pos_value[1], 1);
			lcd_set_cursor(0, 2);
			lcd_printstr("ZP:");
			lcd_printfloat(pos_value[2], 1);
			
			lcd_set_cursor(15, 3);
			lcd_printstr(pos_ctrl);
		}
		// ************************************
		
		
		// SHOW JOINT ANGLE ***********************
		else if(ctrl_mode_counter == 1){
			if(move_var_counter < 3){
				lcd_set_cursor(9, move_var_counter);
				lcd_printstr("<");
			}
			
			else if(move_var_counter > 2){
				lcd_set_cursor(19, move_var_counter-3);
				lcd_printstr("<");
			}
		
			lcd_set_cursor(0, 0);			
			lcd_printstr("A1:");			
			lcd_printfloat(angle_value[0], 1);				
			lcd_set_cursor(0, 1);			
			lcd_printstr("A2:");			
			lcd_printfloat(angle_value[1], 1);				
			lcd_set_cursor(0, 2);			
			lcd_printstr("A3:");			
			lcd_printfloat(angle_value[2], 1);				
			
			lcd_set_cursor(10, 0);
			lcd_printstr("A4:");
			lcd_printfloat(angle_value[3], 1);
			lcd_set_cursor(10, 1);
			lcd_printstr("A5:");
			lcd_printfloat(angle_value[4], 1);
			lcd_set_cursor(10, 2);
			lcd_printstr("A6:");
			lcd_printfloat(angle_value[5], 1);
			
			lcd_set_cursor(15, 3);
			lcd_printstr(angle_ctrl);
		}
		// ****************************************
		
		
		// CONTINUES MOVE **************************************
		lcd_set_cursor(0, 3);	
		if(change_value_counter == 0) lcd_printstr(cont_change);
		
		else if(change_value_counter == 1){
			lcd_printstr(dist_change);
			lcd_set_cursor(6, 3);	
			lcd_printstr(string_distance);
			
			if(!saved_dist && add_col != 0){
				lcd_set_cursor(6+add_col, 3);	
				lcd_printstr("* ");
			} 
			else if(!saved_dist && add_col == 0){
				lcd_set_cursor(7, 3);	
				lcd_printstr("* ");
			}
		}
		// *****************************************************
		
		
		// DISTANCE MOVE ***********************
		else if(change_value_counter == 1){
			lcd_printstr(dist_change);
			lcd_set_cursor(6, 3);	
			lcd_printstr(string_distance);
			
			if(!saved_dist && add_col != 0){
				lcd_set_cursor(6+add_col, 3);	
				lcd_printstr("* ");
			} 
			else if(!saved_dist && add_col == 0){
				lcd_set_cursor(7, 3);	
				lcd_printstr("* ");
			}
		}
		// *************************************
		
		
		// STEP MOVE ************************************************
		else if(change_value_counter == 2) lcd_printstr(step_change);
		// **********************************************************
		
		
		// SHOW CURRENT MENU *********
		if(change_value_counter != 1){
			lcd_set_cursor(7, 3);
			lcd_printstr(mapping_menu);
		}
		// ***************************
	}
	///////////////////////////////////////////////////////////////
	
	
	/* MAPPING MENU 2 *//////////////////////////////////////////////
	else if(menu == MAPPING_MENU && mapping_menu_counter == 1){
		// SHOW CURRENT WELDING INFO **********************************
		lcd_set_cursor(19, move_var_counter);
		lcd_printstr("<");
		
		lcd_set_cursor(0, 0);
		lcd_printstr("Strt Point:");
		if(start_point_counter != 0) lcd_printint(start_point_counter);
		else lcd_printstr("-");
		
		lcd_set_cursor(0, 1);
		lcd_printstr("End Point :");
		if(end_point_counter != 0)  lcd_printint(end_point_counter);
		else lcd_printstr("-");
	
		lcd_set_cursor(0, 3);
		lcd_printstr(mapping_menu);
		
		lcd_set_cursor(15 , 3);
		lcd_printstr(mem_menu);
		// ************************************************************
	}
	/////////////////////////////////////////////////////////////////
	
	
	/* MAPPING MENU 3 *//////////////////////////////////////////////
	else if(menu == MAPPING_MENU && mapping_menu_counter == 2){
		// SHOW CURRENT WELDING INFO **********************************
		lcd_set_cursor(0, 0);
		lcd_printstr("Pattern");
		
		if(pattern_sel_counter == 0){
			lcd_set_cursor(14, 0);
			lcd_printstr(linear_mode);
		}
		else if(pattern_sel_counter == 1){
			lcd_set_cursor(12, 0);
			lcd_printstr(circular_mode);
		}
		else if(pattern_sel_counter == 2){
			lcd_set_cursor(16, 0);
			lcd_printstr(wave_mode);
		}
		
		lcd_set_cursor(0, 1);
		lcd_printstr("Move Spd");
		if(!saved_speed) lcd_printstr("*");
		else lcd_printstr(" ");
		
		lcd_set_cursor(12, 1);
		lcd_printstr(string_speed);
		
		lcd_set_cursor(16, 1);
		lcd_printstr("mm/s");
		
		lcd_set_cursor(0, 3);
		lcd_printstr(mapping_menu);
		
		lcd_set_cursor(15 , 3);
		lcd_printstr(mem_menu);
		// ************************************************************
	}
	/////////////////////////////////////////////////////////////////
	
	
	/* PREVIEW MENU *///////////////////////////////////
	else if(menu == PREVIEW_MENU){
		lcd_set_cursor(0, 0);
		lcd_printstr("Point Pos");
		lcd_set_cursor(17, 0);
		lcd_printint(preview_point);
		
		lcd_set_cursor(0, 1);
		lcd_printstr("Welding Speed");
		lcd_set_cursor(17, 1);
		lcd_printint(preview_speed);
		
		lcd_set_cursor(0, 3);
		lcd_printstr(preview_menu);
		
		if(preview_pattern == 1){
			lcd_set_cursor(12, 3);
			lcd_printstr("(");
			lcd_printstr(linear_mode);
			lcd_printstr(")");
		}
		else if(preview_pattern == 2){
			lcd_set_cursor(10, 3);
			lcd_printstr("(");
			lcd_printstr(circular_mode);
			lcd_printstr(")");
		}
		else if(preview_pattern == 3){
			lcd_set_cursor(14, 3);
			lcd_printstr("(");
			lcd_printstr(wave_mode);
			lcd_printstr(")");
		}
	}
	///////////////////////////////////////////////////

	
	/* WELDING MENU 1*/////////////////////////////////////////
	else if(menu == WELDING_MENU && welding_menu_counter == 0){
		// SHOW CARTESIAN COORDINATE *********
		if(ctrl_mode_counter == 0){
			lcd_set_cursor(9, move_var_counter);
			lcd_printstr("<");
			
			lcd_set_cursor(0, 0);	
			lcd_printstr("XP:");
			lcd_printfloat(pos_value[0], 1);
			lcd_set_cursor(0, 1);
			lcd_printstr("YP:");
			lcd_printfloat(pos_value[1], 1);
			lcd_set_cursor(0, 2);
			lcd_printstr("ZP:");
			lcd_printfloat(pos_value[2], 1);
			
			lcd_set_cursor(15, 3);
			lcd_printstr(pos_ctrl);
		}
		// ***********************************
		
		
		// SHOW JOINT ANGLE ***********************
		else if(ctrl_mode_counter == 1){
			if(move_var_counter < 3){
				lcd_set_cursor(9, move_var_counter);
				lcd_printstr("<");
			}
			
			else if(move_var_counter > 2){
				lcd_set_cursor(19, move_var_counter-3);
				lcd_printstr("<");
			}
		
			lcd_set_cursor(0, 0);			
			lcd_printstr("A1:");			
			lcd_printfloat(angle_value[0], 1);				
			lcd_set_cursor(0, 1);			
			lcd_printstr("A2:");			
			lcd_printfloat(angle_value[1], 1);				
			lcd_set_cursor(0, 2);			
			lcd_printstr("A3:");			
			lcd_printfloat(angle_value[2], 1);				
			
			lcd_set_cursor(10, 0);
			lcd_printstr("A4:");
			lcd_printfloat(angle_value[3], 1);
			lcd_set_cursor(10, 1);
			lcd_printstr("A5:");
			lcd_printfloat(angle_value[4], 1);
			lcd_set_cursor(10, 2);
			lcd_printstr("A6:");
			lcd_printfloat(angle_value[5], 1);
			
			lcd_set_cursor(15, 3);
			lcd_printstr(angle_ctrl);
		}
		// ****************************************
		
		
		// SHOW CURRENT MENU *********
		lcd_set_cursor(0, 3);
		lcd_printstr(welding_menu);
		// ***************************
		
		
		// SHOW CURRENT PATTERN ******
		if(preview_pattern == 1){
			lcd_set_cursor(12, 3);
			lcd_printstr("(");
			lcd_printstr(linear_mode);
			lcd_printstr(")");
		}
		else if(preview_pattern == 2){
			lcd_set_cursor(10, 3);
			lcd_printstr("(");
			lcd_printstr(circular_mode);
			lcd_printstr(")");
		}
		else if(preview_pattern == 3){
			lcd_set_cursor(14, 3);
			lcd_printstr("(");
			lcd_printstr(wave_mode);
			lcd_printstr(")");
		}
		// ***************************
	}
	///////////////////////////////////////////////////////////

	
	/* WELDING MENU 2*/////////////////////////////////////////
	else if(menu == WELDING_MENU && welding_menu_counter == 1){
		lcd_set_cursor(0, 0);
		lcd_printstr("Current Point");
		lcd_set_cursor(17, 0);
		lcd_printint(preview_point);
		
		
		lcd_set_cursor(0, 1);
		lcd_printstr("Current Speed");
		if(speed_mode_counter == 0){
			lcd_set_cursor(17, 1);
			lcd_printstr(low_speed);
		}
		else if(speed_mode_counter == 1){
			lcd_set_cursor(17, 1);
			lcd_printstr(med_speed);
		}
		else if(speed_mode_counter == 2){
			lcd_set_cursor(16, 1);
			lcd_printstr(high_speed);
		}
		
		lcd_set_cursor(0, 2);
		lcd_printstr("Welding Speed");
		lcd_set_cursor(17, 0);
		lcd_printint(preview_speed);
	}
	///////////////////////////////////////////////////////////
	
	
	/* MAPPING SAVE MENU */
	else if(menu == MAPPING_SAVE_MENU){
		lcd_set_cursor(2, 1);
		lcd_printstr("SAVING PARAMETER");
		lcd_set_cursor(4, 2);
		lcd_printstr("PLEASE  WAIT");
	}
	
	/* MAPPING ERROR MENU *////////////////
	else if(menu == MAPPING_ERROR_MENU){
		lcd_set_cursor(3, 0);
		lcd_printstr("WELDING  POINT");
		lcd_set_cursor(2, 1);
		lcd_printstr("NO SET CORRECTLY");
		lcd_set_cursor(3, 3);
		lcd_printstr("PLEASE REPEAT");
	}
	///////////////////////////////////////
	
	
	/* PREVIEW ERROR MENU *//////////////
	else if(menu == PREVIEW_ERROR_MENU){
		lcd_set_cursor(3, 1);
		lcd_printstr("SELECTED POINT");
		lcd_set_cursor(5, 2);
		lcd_printstr("NOT  FOUND");
	}
	/////////////////////////////////////
	
	
	/* POINT SET MENU*///////////////
	else if(menu == POINT_SET_MENU){
		lcd_set_cursor(4, 1);
		lcd_printstr("WELDING POINT");
		lcd_set_cursor(7, 2);
		lcd_printstr("SETTED");
	}
	/////////////////////////////////
	
	
	/* POINT UNSET MENU *//////////////
	else if(menu == POINT_UNSET_MENU){
		lcd_set_cursor(4, 1);
		lcd_printstr("WELDING POINT");
		lcd_set_cursor(6, 2);
		lcd_printstr("UNSETTED");
	}
	///////////////////////////////////
	
	
	/* PAUSE MENU */////////////////
	else if(menu == PAUSE_MENU){
		lcd_set_cursor(2, 1);
		lcd_printstr("WELDING  PROCESS");
		lcd_set_cursor(6, 2);
		lcd_printstr("PAUSED");
	}
	////////////////////////////////
	
	
	/* STOP MENU *////////////////////
	else if(menu == STOP_MENU){
		lcd_set_cursor(2, 0);
		lcd_printstr("WELDING  PROCESS");
		lcd_set_cursor(6, 1);
		lcd_printstr("STOPED");
		lcd_set_cursor(4, 3);
		lcd_printstr("ROBOT HOMING");
	}
	//////////////////////////////////
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*--- CHECK PRESSED NUMKEYS ---*/
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool check_numkeys_pressed(void){
	keys = Keypad_Read(&keypad);
	
	for(int i=0; i<sizeof(num_keys); i++) if(keys == num_keys[i]) return true;
	return false;
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*--- SAVE WELDING DATA ---*/
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void Save_WeldingData(uint8_t welding_point, uint8_t welding_pattern, uint8_t welding_speed){
	uint8_t save_data[3] = {welding_point, welding_pattern, welding_speed};
	EEPROM_PageWrite(&eeprom, welding_point-1, 0, save_data, sizeof(save_data));
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*--- DELETE WELDING DATA ---*/
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void Delete_WeldingData(uint8_t welding_point){
	EEPROM_PageReset(&eeprom, welding_point-1, 0);
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*--- READ WELDING DATA ---*/
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void Read_WeldingData(uint8_t welding_point, uint8_t* stored_data){
	EEPROM_PageRead(&eeprom, welding_point-1, 0, stored_data, sizeof(stored_data));
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*--- UPDATE EEPROM STORED DATA ---*/
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void Update_Data(Mem_Update_t update_type){
	if(update_type == UPDATE_ALL){
		for(uint8_t i=1; i<max_welding_point; i++){
			Read_WeldingData(i, stored_welding_data);
			
			if(stored_welding_data[0] != 0){
				total_mapped_points++;
				mapped_points[i-1] 	= stored_welding_data[0];
				mapped_pattern[i-1] = stored_welding_data[1];
				mapped_speed[i-1] 	= stored_welding_data[2];
			}
			else{
				mapped_points[i-1] 	= 0;
				mapped_pattern[i-1] = 0;
				mapped_speed[i-1] 	= 0;
			}
			
			HAL_Delay(10);
		}
	}
	
	else if(update_type == SELECTED_ONLY){
		HAL_Delay(1000);
		Read_WeldingData(start_point_counter, stored_welding_data);
		mapped_points[start_point_counter-1] 	= stored_welding_data[0];
		mapped_pattern[start_point_counter-1] = stored_welding_data[1];
		mapped_speed[start_point_counter-1] 	= stored_welding_data[2];
	}
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*--- FORMAT EEPROM MEMORY ---*/
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void format_mem(void){
	for(uint8_t i=0; i<max_welding_point; i++){
		for(uint8_t j=0; j<64; j++){
			EEPROM_ByteWrite(&eeprom, i, j, 0x00, 1);
		}
	}
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
